<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Postgresql on Blog</title>
    <link>https://spokey.co.uk/categories/postgresql/</link>
    <description>Recent content in Postgresql on Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 25 Apr 2025 14:18:39 +0100</lastBuildDate>
    <atom:link href="https://spokey.co.uk/categories/postgresql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Query Performance Improvement Part 5</title>
      <link>https://spokey.co.uk/post/query-performance-improvement-part-5/</link>
      <pubDate>Wed, 23 Apr 2025 12:07:07 +0100</pubDate>
      <guid>https://spokey.co.uk/post/query-performance-improvement-part-5/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-1&#34;&gt;Part 1&lt;/a&gt; looks at some principles and introduces some of the tools in your arsenal.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-2&#34;&gt;Part 2&lt;/a&gt; covers the dreaded PostgreSQL bloat issue as well as how TOAST can help performance, or hinder it.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-3&#34;&gt;Part 3&lt;/a&gt; dives deeper into identifying, investigating and mitigating slow queries.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-4&#34;&gt;Part 4&lt;/a&gt; covers indexes.&lt;/p&gt;&#xA;&lt;p&gt;Part 5 (this post) covers rewriting queries.&lt;/p&gt;&#xA;&lt;h1 id=&#34;tldr&#34;&gt;TL;DR&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Break your query down using CTEs&lt;/li&gt;&#xA;&lt;li&gt;Optimise each step&lt;/li&gt;&#xA;&lt;li&gt;Rewrite using what you&amp;rsquo;ve learned (if you want to)&lt;/li&gt;&#xA;&lt;li&gt;Visualising an explain plan can really make problems obvious, compared to sifting through a sea of text&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;rewriting-queries&#34;&gt;Rewriting queries&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bench=# \d pgbench_accounts&#xA;              Table &amp;#34;public.pgbench_accounts&amp;#34;&#xA;  Column  |     Type      | Collation | Nullable | Default&#xA;----------+---------------+-----------+----------+---------&#xA; aid      | integer       |           | not null |&#xA; bid      | integer       |           |          |&#xA; abalance | integer       |           |          |&#xA; filler   | character(84) |           |          |&#xA;Indexes:&#xA;    &amp;#34;pgbench_accounts_pkey&amp;#34; PRIMARY KEY, btree (aid)&#xA;    &amp;#34;i_pa2&amp;#34; btree (aid, abalance, bid) WHERE aid &amp;gt; 0 AND aid &amp;lt; 194999 AND abalance &amp;lt; &amp;#39;-4500&amp;#39;::integer AND abalance &amp;gt; &amp;#39;-5000&amp;#39;::integer&#xA;Foreign-key constraints:&#xA;    &amp;#34;pgbench_accounts_bid_fkey&amp;#34; FOREIGN KEY (bid) REFERENCES pgbench_branches(bid)&#xA;Referenced by:&#xA;    TABLE &amp;#34;pgbench_history&amp;#34; CONSTRAINT &amp;#34;pgbench_history_aid_fkey&amp;#34; FOREIGN KEY (aid) REFERENCES pgbench_accounts(aid)&#xA;&#xA;bench=# \d pgbench_branches&#xA;              Table &amp;#34;public.pgbench_branches&amp;#34;&#xA;  Column  |     Type      | Collation | Nullable | Default&#xA;----------+---------------+-----------+----------+---------&#xA; bid      | integer       |           | not null |&#xA; bbalance | integer       |           |          |&#xA; filler   | character(88) |           |          |&#xA;Indexes:&#xA;    &amp;#34;pgbench_branches_pkey&amp;#34; PRIMARY KEY, btree (bid)&#xA;Referenced by:&#xA;    TABLE &amp;#34;pgbench_accounts&amp;#34; CONSTRAINT &amp;#34;pgbench_accounts_bid_fkey&amp;#34; FOREIGN KEY (bid) REFERENCES pgbench_branches(bid)&#xA;    TABLE &amp;#34;pgbench_history&amp;#34; CONSTRAINT &amp;#34;pgbench_history_bid_fkey&amp;#34; FOREIGN KEY (bid) REFERENCES pgbench_branches(bid)&#xA;    TABLE &amp;#34;pgbench_tellers&amp;#34; CONSTRAINT &amp;#34;pgbench_tellers_bid_fkey&amp;#34; FOREIGN KEY (bid) REFERENCES pgbench_branches(bid)&#xA;&#xA;bench=# \d pgbench_history&#xA;                    Table &amp;#34;public.pgbench_history&amp;#34;&#xA; Column |            Type             | Collation | Nullable | Default&#xA;--------+-----------------------------+-----------+----------+---------&#xA; tid    | integer                     |           |          |&#xA; bid    | integer                     |           |          |&#xA; aid    | integer                     |           |          |&#xA; delta  | integer                     |           |          |&#xA; mtime  | timestamp without time zone |           |          |&#xA; filler | character(22)               |           |          |&#xA;Indexes:&#xA;    &amp;#34;i1&amp;#34; btree (aid, delta) WHERE delta &amp;lt; 0&#xA;Foreign-key constraints:&#xA;    &amp;#34;pgbench_history_aid_fkey&amp;#34; FOREIGN KEY (aid) REFERENCES pgbench_accounts(aid)&#xA;    &amp;#34;pgbench_history_bid_fkey&amp;#34; FOREIGN KEY (bid) REFERENCES pgbench_branches(bid)&#xA;    &amp;#34;pgbench_history_tid_fkey&amp;#34; FOREIGN KEY (tid) REFERENCES pgbench_tellers(tid)&#xA;&#xA;bench=# \d pgbench_tellers&#xA;              Table &amp;#34;public.pgbench_tellers&amp;#34;&#xA;  Column  |     Type      | Collation | Nullable | Default&#xA;----------+---------------+-----------+----------+---------&#xA; tid      | integer       |           | not null |&#xA; bid      | integer       |           |          |&#xA; tbalance | integer       |           |          |&#xA; filler   | character(84) |           |          |&#xA;Indexes:&#xA;    &amp;#34;pgbench_tellers_pkey&amp;#34; PRIMARY KEY, btree (tid)&#xA;Foreign-key constraints:&#xA;    &amp;#34;pgbench_tellers_bid_fkey&amp;#34; FOREIGN KEY (bid) REFERENCES pgbench_branches(bid)&#xA;Referenced by:&#xA;    TABLE &amp;#34;pgbench_history&amp;#34; CONSTRAINT &amp;#34;pgbench_history_tid_fkey&amp;#34; FOREIGN KEY (tid) REFERENCES pgbench_tellers(tid)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;joins&#34;&gt;Joins&lt;/h2&gt;&#xA;&lt;p&gt;We have already covered one aspect of query rewriting, namely how to rewrite joins, which we covered in &lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-3/&#34;&gt;Query Performance Improvement Part 3&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Query Performance Improvement Part 4</title>
      <link>https://spokey.co.uk/post/query-performance-improvement-part-4/</link>
      <pubDate>Wed, 23 Apr 2025 12:07:01 +0100</pubDate>
      <guid>https://spokey.co.uk/post/query-performance-improvement-part-4/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-1&#34;&gt;Part 1&lt;/a&gt; looks at some principles and introduces some of the tools in your arsenal.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-2&#34;&gt;Part 2&lt;/a&gt; covers the dreaded PostgreSQL bloat issue as well as how TOAST can help performance, or hinder it.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-3&#34;&gt;Part 3&lt;/a&gt; dives deeper into identifying, investigating and mitigating slow queries.&lt;/p&gt;&#xA;&lt;p&gt;Part 4 (this post) covers indexing.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-5&#34;&gt;Part 5&lt;/a&gt; covers rewriting queries.&lt;/p&gt;&#xA;&lt;h1 id=&#34;tldr&#34;&gt;TL;DR&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;If you see &amp;ldquo;Filter:&amp;rdquo; or &amp;ldquo;Rows Removed&amp;rdquo; in your explain plan, you are likely to be using the wrong index&lt;/li&gt;&#xA;&lt;li&gt;Composite indexes can be much faster than multiple single indexes&lt;/li&gt;&#xA;&lt;li&gt;Partial indexes reduce the height and size of the index, making them faster&lt;/li&gt;&#xA;&lt;li&gt;Covering indexes can speed queries even further&lt;/li&gt;&#xA;&lt;li&gt;The bigger the table, the more likely it is that an index will add value&lt;/li&gt;&#xA;&lt;li&gt;Small tables are often sequentially scanned, whether indexed or not&lt;/li&gt;&#xA;&lt;li&gt;Small to medium tables tend to benefit from single column indexes, less from more complex indexes&lt;/li&gt;&#xA;&lt;li&gt;Large tables tend to benefit more from complex indexes&lt;/li&gt;&#xA;&lt;li&gt;Always test before pushing to production!&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;indexes&#34;&gt;Indexes&lt;/h1&gt;&#xA;&lt;p&gt;Indexes are one of the most effective tools to improve query performance. Indexes work best when they return a small subset of data and are small compared to row size. So an 8-byte integer index on a 2kB row is more efficient than a 1kB text index on a 1.5kB row.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Query Performance Improvement Part 3</title>
      <link>https://spokey.co.uk/post/query-performance-improvement-part-3/</link>
      <pubDate>Sun, 20 Apr 2025 13:55:43 +0100</pubDate>
      <guid>https://spokey.co.uk/post/query-performance-improvement-part-3/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-1&#34;&gt;Part 1&lt;/a&gt; looks at some principles and introduces some of the tools in your arsenal.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-2&#34;&gt;Part 2&lt;/a&gt; covers the dreaded PostgreSQL bloat issue as well as how TOAST can help performance, or hinder it.&lt;/p&gt;&#xA;&lt;p&gt;Part 3 (this post) dives deeper into identifying, investigating and mitigating slow queries.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-4&#34;&gt;Part 4&lt;/a&gt; covers indexing.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-5&#34;&gt;Part 5&lt;/a&gt; covers rewriting queries.&lt;/p&gt;&#xA;&lt;h1 id=&#34;tldr&#34;&gt;TL;DR&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Use logging to identify slow queries&lt;/li&gt;&#xA;&lt;li&gt;Use &lt;code&gt;EXPLAIN&lt;/code&gt; to examine an explain plan&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;EXPLAIN (ANALYZE)&lt;/code&gt; can be dangerous!&lt;/li&gt;&#xA;&lt;li&gt;Use &lt;a href=&#34;https://explain.depesz.com&#34;&gt;depesz&lt;/a&gt;, &lt;a href=&#34;https://explain.dalibo.com&#34;&gt;dalibo&lt;/a&gt; or &lt;a href=&#34;https://tatiyants.com/pev/#/plans/new&#34;&gt;PEV&lt;/a&gt; to visualize your explain plan&lt;/li&gt;&#xA;&lt;li&gt;Red flags in your explain plan include filters, Rows Removed, and / or costs in excess of 100,000&lt;/li&gt;&#xA;&lt;li&gt;Data may not be evenly distributed, check it! Especially test data!&lt;/li&gt;&#xA;&lt;li&gt;Only select the rows and columns you need&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;identifying-slow-queries&#34;&gt;Identifying slow queries&lt;/h1&gt;&#xA;&lt;p&gt;The most reliable way of identifying slow queries is to enable slow query logging using the parameter &lt;a href=&#34;https://www.postgresql.org/docs/17/runtime-config-logging.html#GUC-LOG-MIN-DURATION-STATEMENT&#34;&gt;log_min_duration_statement&lt;/a&gt;. The pain threshold varies by environment, but for example if you wanted to log all queries that take longer than 50ms, you would issue the following command in psql:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Query Performance Improvement Part 2</title>
      <link>https://spokey.co.uk/post/query-performance-improvement-part-2/</link>
      <pubDate>Sun, 20 Apr 2025 10:53:36 +0100</pubDate>
      <guid>https://spokey.co.uk/post/query-performance-improvement-part-2/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-1&#34;&gt;Part 1&lt;/a&gt; looks at some principles and introduces some of the tools in your arsenal.&lt;/p&gt;&#xA;&lt;p&gt;Part 2 (this post) covers the dreaded PostgreSQL bloat issue as well as how TOAST can help performance, or hinder it.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-3&#34;&gt;Part 3&lt;/a&gt; dives deeper into identifying, investigating and mitigating slow queries.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-4&#34;&gt;Part 4&lt;/a&gt; covers indexing.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-5&#34;&gt;Part 5&lt;/a&gt; covers rewriting queries.&lt;/p&gt;&#xA;&lt;h1 id=&#34;tldr&#34;&gt;TL;DR&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Bloat occurs because PostgreSQL does not update in place, it creates a new row and marks the old one as obsolete&lt;/li&gt;&#xA;&lt;li&gt;VACUUM fixes bloat, well, it marks obsolete rows as re-usable space&lt;/li&gt;&#xA;&lt;li&gt;VACUUM FULL fixes bloat by compactly rewriting the data file and rebuilding indexes&lt;/li&gt;&#xA;&lt;li&gt;You should never run VACUUM FULL because it requires a full table lock&lt;/li&gt;&#xA;&lt;li&gt;pg_repack is an option &amp;hellip; possibly&lt;/li&gt;&#xA;&lt;li&gt;Use pg_repack with care - it can have problematic side effects&lt;/li&gt;&#xA;&lt;li&gt;TOAST compresses wide columns so that the resulting row is &amp;lt; 2kB&lt;/li&gt;&#xA;&lt;li&gt;If the table is still too wide, then compressed wide columns are split into 2kB chunks and move to a TOAST table&lt;/li&gt;&#xA;&lt;li&gt;A 2kB (ish) wide table can be problematic&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;bloat&#34;&gt;Bloat&lt;/h1&gt;&#xA;&lt;h2 id=&#34;what-is-bloat&#34;&gt;What is bloat?&lt;/h2&gt;&#xA;&lt;p&gt;Strictly speaking, bloat is the unused space left behind by a VACUUM that is not a VACUUM FULL.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Query Performance Improvement Part 1</title>
      <link>https://spokey.co.uk/post/query-performance-improvement-part-1/</link>
      <pubDate>Sat, 19 Apr 2025 01:30:19 +0100</pubDate>
      <guid>https://spokey.co.uk/post/query-performance-improvement-part-1/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;&#xA;&lt;p&gt;Part 1 (this post) looks at some principles and introduces some of the tools in your arsenal.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-2&#34;&gt;Part 2&lt;/a&gt; covers the dreaded PostgreSQL bloat issue as well as how TOAST can help performance, or not.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-3&#34;&gt;Part 3&lt;/a&gt; dives deeper into identifying, investigating and mitigating slow queries.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-4&#34;&gt;Part 4&lt;/a&gt; covers indexing.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-5&#34;&gt;Part 5&lt;/a&gt; covers rewriting queries.&lt;/p&gt;&#xA;&lt;h1 id=&#34;tldr&#34;&gt;TL;DR&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Scaling up or out is more expensive than spending a couple of hours optimising&lt;/li&gt;&#xA;&lt;li&gt;Get answers, not data&lt;/li&gt;&#xA;&lt;li&gt;Lazy load lookups&lt;/li&gt;&#xA;&lt;li&gt;Eliminate non-essential queries&lt;/li&gt;&#xA;&lt;li&gt;Don&amp;rsquo;t use SERIALIZABLE isolation&lt;/li&gt;&#xA;&lt;li&gt;Make sure auto-analyze is running and have a manual ANALYZE schedule as a safety net&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;&#xA;&lt;p&gt;Welcome to this series of blog posts which will hopefully walk you through everything you need to know about improving query performance, specifically in PostgreSQL. The basic principles apply to all databases, though, even if implementation differences mean that different databases find different things painful.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
