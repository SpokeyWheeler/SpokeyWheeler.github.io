<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog</title>
    <link>https://spokey.co.uk/</link>
    <description>Recent content on Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 02 May 2025 13:50:29 +0100</lastBuildDate>
    <atom:link href="https://spokey.co.uk/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Always Use a Surrogate Primary Key</title>
      <link>https://spokey.co.uk/post/always-use-a-surrogate-primary-key/</link>
      <pubDate>Sat, 26 Apr 2025 10:49:47 +0100</pubDate>
      <guid>https://spokey.co.uk/post/always-use-a-surrogate-primary-key/</guid>
      <description>&lt;h1 id=&#34;always-use-a-surrogate-primarykey&#34;&gt;Always use a Surrogate Primary Key&lt;/h1&gt;&#xA;&lt;p&gt;Many years ago, when I was still in possession of my hair, I entered a subcontract to develop a system to replace paper-based case files for a quango in South Africa.&lt;/p&gt;&#xA;&lt;p&gt;The main contract was held by a large development shop that specialised in a related, but different field. They had given one of their systems analysts the task of analysing the system (duh!) but had no spare capacity to code it, so they farmed it out to me.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ansible Antipatterns</title>
      <link>https://spokey.co.uk/post/ansible-antipatterns/</link>
      <pubDate>Sat, 26 Apr 2025 10:32:52 +0100</pubDate>
      <guid>https://spokey.co.uk/post/ansible-antipatterns/</guid>
      <description>&lt;h1 id=&#34;ansible-antipatterns&#34;&gt;Ansible Antipatterns&lt;/h1&gt;&#xA;&lt;p&gt;Lots of people tell you how to do things properly. Here are some things I&amp;rsquo;ve inherited in our Ansible that break things in horrible ways.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://spokey.co.uk/images/carlos-irineu-da-costa-eMc0lpn1P60-unsplash.jpg&#34; alt=&#34;Workshop&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;coupling&#34;&gt;Coupling&lt;/h1&gt;&#xA;&lt;p&gt;Coupling is (roughly) how interconnected different components of a system are. One of the most common patterns in modern software engineering is loose coupling.&lt;/p&gt;&#xA;&lt;p&gt;The idea of separating things across an API so that you can change things behind the API without having to change other components is very powerful.&lt;/p&gt;</description>
    </item>
    <item>
      <title>The Forgotten Aspect of DBRE</title>
      <link>https://spokey.co.uk/post/the-forgotten-aspect-of-dbre/</link>
      <pubDate>Sat, 26 Apr 2025 09:51:11 +0100</pubDate>
      <guid>https://spokey.co.uk/post/the-forgotten-aspect-of-dbre/</guid>
      <description>&lt;hr&gt;&#xA;&lt;h1 id=&#34;the-forgotten-aspect-ofdbre&#34;&gt;The Forgotten Aspect of DBRE&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://spokey.co.uk/images/TheHorror.jpg&#34; alt=&#34;The horror&amp;hellip; the horror&amp;hellip;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;I am a great fan of the DBRE book, and an avid follower of the authors&amp;rsquo; podcasts, videos and blog posts.&lt;/p&gt;&#xA;&lt;p&gt;But there is one glaring omission that I can&amp;rsquo;t find discussed properly anywhere: upgrades.&lt;/p&gt;&#xA;&lt;p&gt;You need to patch to fix bugs or address vulnerabilities. You need to upgrade for support and new features that developers want.&lt;/p&gt;&#xA;&lt;p&gt;I understand that site-specific needs make it hard to proclaim detailed edicts. But the DBRE book isn&amp;rsquo;t about detailed edicts. It&amp;rsquo;s about principles and a way of working.&lt;/p&gt;</description>
    </item>
    <item>
      <title>DBRE: What Is Your MVP?</title>
      <link>https://spokey.co.uk/post/dbre-what-is-your-mvp/</link>
      <pubDate>Fri, 25 Apr 2025 20:06:00 +0100</pubDate>
      <guid>https://spokey.co.uk/post/dbre-what-is-your-mvp/</guid>
      <description>&lt;h1 id=&#34;or-a-litany-of-errors&#34;&gt;Or, “a litany of errors”&lt;/h1&gt;&#xA;&lt;p&gt;The lean model for continuous improvement looks something like this:&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://spokey.co.uk/images/LeanModel.png&#34; alt=&#34;Lean&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Where you start is a matter of some debate, as is the direction of flow. However, most people start with the idea of building a Minimum Viable Product (MVP) as an experiment; measuring the results; and then learning from the measures they recorded, which then feeds into the next build of the product.&lt;/p&gt;&#xA;&lt;p&gt;What is an MVP for a Database Reliability Engineer (DBRE)? A good, old-fashioned manual install. A best practices manual install.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Query Performance Improvement Part 5</title>
      <link>https://spokey.co.uk/post/query-performance-improvement-part-5/</link>
      <pubDate>Wed, 23 Apr 2025 12:07:07 +0100</pubDate>
      <guid>https://spokey.co.uk/post/query-performance-improvement-part-5/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-1&#34;&gt;Part 1&lt;/a&gt; looks at some principles and introduces some of the tools in your arsenal.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-2&#34;&gt;Part 2&lt;/a&gt; covers the dreaded PostgreSQL bloat issue as well as how TOAST can help performance, or hinder it.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-3&#34;&gt;Part 3&lt;/a&gt; dives deeper into identifying, investigating and mitigating slow queries.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-4&#34;&gt;Part 4&lt;/a&gt; covers indexes.&lt;/p&gt;&#xA;&lt;p&gt;Part 5 (this post) covers rewriting queries.&lt;/p&gt;&#xA;&lt;h1 id=&#34;tldr&#34;&gt;TL;DR&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Break your query down using CTEs&lt;/li&gt;&#xA;&lt;li&gt;Optimise each step&lt;/li&gt;&#xA;&lt;li&gt;Rewrite using what you&amp;rsquo;ve learned (if you want to)&lt;/li&gt;&#xA;&lt;li&gt;Visualising an explain plan can really make problems obvious, compared to sifting through a sea of text&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;rewriting-queries&#34;&gt;Rewriting queries&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bench=# \d pgbench_accounts&#xA;              Table &amp;#34;public.pgbench_accounts&amp;#34;&#xA;  Column  |     Type      | Collation | Nullable | Default&#xA;----------+---------------+-----------+----------+---------&#xA; aid      | integer       |           | not null |&#xA; bid      | integer       |           |          |&#xA; abalance | integer       |           |          |&#xA; filler   | character(84) |           |          |&#xA;Indexes:&#xA;    &amp;#34;pgbench_accounts_pkey&amp;#34; PRIMARY KEY, btree (aid)&#xA;    &amp;#34;i_pa2&amp;#34; btree (aid, abalance, bid) WHERE aid &amp;gt; 0 AND aid &amp;lt; 194999 AND abalance &amp;lt; &amp;#39;-4500&amp;#39;::integer AND abalance &amp;gt; &amp;#39;-5000&amp;#39;::integer&#xA;Foreign-key constraints:&#xA;    &amp;#34;pgbench_accounts_bid_fkey&amp;#34; FOREIGN KEY (bid) REFERENCES pgbench_branches(bid)&#xA;Referenced by:&#xA;    TABLE &amp;#34;pgbench_history&amp;#34; CONSTRAINT &amp;#34;pgbench_history_aid_fkey&amp;#34; FOREIGN KEY (aid) REFERENCES pgbench_accounts(aid)&#xA;&#xA;bench=# \d pgbench_branches&#xA;              Table &amp;#34;public.pgbench_branches&amp;#34;&#xA;  Column  |     Type      | Collation | Nullable | Default&#xA;----------+---------------+-----------+----------+---------&#xA; bid      | integer       |           | not null |&#xA; bbalance | integer       |           |          |&#xA; filler   | character(88) |           |          |&#xA;Indexes:&#xA;    &amp;#34;pgbench_branches_pkey&amp;#34; PRIMARY KEY, btree (bid)&#xA;Referenced by:&#xA;    TABLE &amp;#34;pgbench_accounts&amp;#34; CONSTRAINT &amp;#34;pgbench_accounts_bid_fkey&amp;#34; FOREIGN KEY (bid) REFERENCES pgbench_branches(bid)&#xA;    TABLE &amp;#34;pgbench_history&amp;#34; CONSTRAINT &amp;#34;pgbench_history_bid_fkey&amp;#34; FOREIGN KEY (bid) REFERENCES pgbench_branches(bid)&#xA;    TABLE &amp;#34;pgbench_tellers&amp;#34; CONSTRAINT &amp;#34;pgbench_tellers_bid_fkey&amp;#34; FOREIGN KEY (bid) REFERENCES pgbench_branches(bid)&#xA;&#xA;bench=# \d pgbench_history&#xA;                    Table &amp;#34;public.pgbench_history&amp;#34;&#xA; Column |            Type             | Collation | Nullable | Default&#xA;--------+-----------------------------+-----------+----------+---------&#xA; tid    | integer                     |           |          |&#xA; bid    | integer                     |           |          |&#xA; aid    | integer                     |           |          |&#xA; delta  | integer                     |           |          |&#xA; mtime  | timestamp without time zone |           |          |&#xA; filler | character(22)               |           |          |&#xA;Indexes:&#xA;    &amp;#34;i1&amp;#34; btree (aid, delta) WHERE delta &amp;lt; 0&#xA;Foreign-key constraints:&#xA;    &amp;#34;pgbench_history_aid_fkey&amp;#34; FOREIGN KEY (aid) REFERENCES pgbench_accounts(aid)&#xA;    &amp;#34;pgbench_history_bid_fkey&amp;#34; FOREIGN KEY (bid) REFERENCES pgbench_branches(bid)&#xA;    &amp;#34;pgbench_history_tid_fkey&amp;#34; FOREIGN KEY (tid) REFERENCES pgbench_tellers(tid)&#xA;&#xA;bench=# \d pgbench_tellers&#xA;              Table &amp;#34;public.pgbench_tellers&amp;#34;&#xA;  Column  |     Type      | Collation | Nullable | Default&#xA;----------+---------------+-----------+----------+---------&#xA; tid      | integer       |           | not null |&#xA; bid      | integer       |           |          |&#xA; tbalance | integer       |           |          |&#xA; filler   | character(84) |           |          |&#xA;Indexes:&#xA;    &amp;#34;pgbench_tellers_pkey&amp;#34; PRIMARY KEY, btree (tid)&#xA;Foreign-key constraints:&#xA;    &amp;#34;pgbench_tellers_bid_fkey&amp;#34; FOREIGN KEY (bid) REFERENCES pgbench_branches(bid)&#xA;Referenced by:&#xA;    TABLE &amp;#34;pgbench_history&amp;#34; CONSTRAINT &amp;#34;pgbench_history_tid_fkey&amp;#34; FOREIGN KEY (tid) REFERENCES pgbench_tellers(tid)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;joins&#34;&gt;Joins&lt;/h2&gt;&#xA;&lt;p&gt;We have already covered one aspect of query rewriting, namely how to rewrite joins, which we covered in &lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-3/&#34;&gt;Query Performance Improvement Part 3&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Query Performance Improvement Part 4</title>
      <link>https://spokey.co.uk/post/query-performance-improvement-part-4/</link>
      <pubDate>Wed, 23 Apr 2025 12:07:01 +0100</pubDate>
      <guid>https://spokey.co.uk/post/query-performance-improvement-part-4/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-1&#34;&gt;Part 1&lt;/a&gt; looks at some principles and introduces some of the tools in your arsenal.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-2&#34;&gt;Part 2&lt;/a&gt; covers the dreaded PostgreSQL bloat issue as well as how TOAST can help performance, or hinder it.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-3&#34;&gt;Part 3&lt;/a&gt; dives deeper into identifying, investigating and mitigating slow queries.&lt;/p&gt;&#xA;&lt;p&gt;Part 4 (this post) covers indexing.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-5&#34;&gt;Part 5&lt;/a&gt; covers rewriting queries.&lt;/p&gt;&#xA;&lt;h1 id=&#34;tldr&#34;&gt;TL;DR&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;If you see &amp;ldquo;Filter:&amp;rdquo; or &amp;ldquo;Rows Removed&amp;rdquo; in your explain plan, you are likely to be using the wrong index&lt;/li&gt;&#xA;&lt;li&gt;Composite indexes can be much faster than multiple single indexes&lt;/li&gt;&#xA;&lt;li&gt;Partial indexes reduce the height and size of the index, making them faster&lt;/li&gt;&#xA;&lt;li&gt;Covering indexes can speed queries even further&lt;/li&gt;&#xA;&lt;li&gt;The bigger the table, the more likely it is that an index will add value&lt;/li&gt;&#xA;&lt;li&gt;Small tables are often sequentially scanned, whether indexed or not&lt;/li&gt;&#xA;&lt;li&gt;Small to medium tables tend to benefit from single column indexes, less from more complex indexes&lt;/li&gt;&#xA;&lt;li&gt;Large tables tend to benefit more from complex indexes&lt;/li&gt;&#xA;&lt;li&gt;Always test before pushing to production!&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;indexes&#34;&gt;Indexes&lt;/h1&gt;&#xA;&lt;p&gt;Indexes are one of the most effective tools to improve query performance. Indexes work best when they return a small subset of data and are small compared to row size. So an 8-byte integer index on a 2kB row is more efficient than a 1kB text index on a 1.5kB row.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Query Performance Improvement Part 3</title>
      <link>https://spokey.co.uk/post/query-performance-improvement-part-3/</link>
      <pubDate>Sun, 20 Apr 2025 13:55:43 +0100</pubDate>
      <guid>https://spokey.co.uk/post/query-performance-improvement-part-3/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-1&#34;&gt;Part 1&lt;/a&gt; looks at some principles and introduces some of the tools in your arsenal.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-2&#34;&gt;Part 2&lt;/a&gt; covers the dreaded PostgreSQL bloat issue as well as how TOAST can help performance, or hinder it.&lt;/p&gt;&#xA;&lt;p&gt;Part 3 (this post) dives deeper into identifying, investigating and mitigating slow queries.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-4&#34;&gt;Part 4&lt;/a&gt; covers indexing.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-5&#34;&gt;Part 5&lt;/a&gt; covers rewriting queries.&lt;/p&gt;&#xA;&lt;h1 id=&#34;tldr&#34;&gt;TL;DR&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Use logging to identify slow queries&lt;/li&gt;&#xA;&lt;li&gt;Use &lt;code&gt;EXPLAIN&lt;/code&gt; to examine an explain plan&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;EXPLAIN (ANALYZE)&lt;/code&gt; can be dangerous!&lt;/li&gt;&#xA;&lt;li&gt;Use &lt;a href=&#34;https://explain.depesz.com&#34;&gt;depesz&lt;/a&gt;, &lt;a href=&#34;https://explain.dalibo.com&#34;&gt;dalibo&lt;/a&gt; or &lt;a href=&#34;https://tatiyants.com/pev/#/plans/new&#34;&gt;PEV&lt;/a&gt; to visualize your explain plan&lt;/li&gt;&#xA;&lt;li&gt;Red flags in your explain plan include filters, Rows Removed, and / or costs in excess of 100,000&lt;/li&gt;&#xA;&lt;li&gt;Data may not be evenly distributed, check it! Especially test data!&lt;/li&gt;&#xA;&lt;li&gt;Only select the rows and columns you need&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;identifying-slow-queries&#34;&gt;Identifying slow queries&lt;/h1&gt;&#xA;&lt;p&gt;The most reliable way of identifying slow queries is to enable slow query logging using the parameter &lt;a href=&#34;https://www.postgresql.org/docs/17/runtime-config-logging.html#GUC-LOG-MIN-DURATION-STATEMENT&#34;&gt;log_min_duration_statement&lt;/a&gt;. The pain threshold varies by environment, but for example if you wanted to log all queries that take longer than 50ms, you would issue the following command in psql:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Query Performance Improvement Part 2</title>
      <link>https://spokey.co.uk/post/query-performance-improvement-part-2/</link>
      <pubDate>Sun, 20 Apr 2025 10:53:36 +0100</pubDate>
      <guid>https://spokey.co.uk/post/query-performance-improvement-part-2/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-1&#34;&gt;Part 1&lt;/a&gt; looks at some principles and introduces some of the tools in your arsenal.&lt;/p&gt;&#xA;&lt;p&gt;Part 2 (this post) covers the dreaded PostgreSQL bloat issue as well as how TOAST can help performance, or hinder it.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-3&#34;&gt;Part 3&lt;/a&gt; dives deeper into identifying, investigating and mitigating slow queries.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-4&#34;&gt;Part 4&lt;/a&gt; covers indexing.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-5&#34;&gt;Part 5&lt;/a&gt; covers rewriting queries.&lt;/p&gt;&#xA;&lt;h1 id=&#34;tldr&#34;&gt;TL;DR&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Bloat occurs because PostgreSQL does not update in place, it creates a new row and marks the old one as obsolete&lt;/li&gt;&#xA;&lt;li&gt;VACUUM fixes bloat, well, it marks obsolete rows as re-usable space&lt;/li&gt;&#xA;&lt;li&gt;VACUUM FULL fixes bloat by compactly rewriting the data file and rebuilding indexes&lt;/li&gt;&#xA;&lt;li&gt;You should never run VACUUM FULL because it requires a full table lock&lt;/li&gt;&#xA;&lt;li&gt;pg_repack is an option &amp;hellip; possibly&lt;/li&gt;&#xA;&lt;li&gt;Use pg_repack with care - it can have problematic side effects&lt;/li&gt;&#xA;&lt;li&gt;TOAST compresses wide columns so that the resulting row is &amp;lt; 2kB&lt;/li&gt;&#xA;&lt;li&gt;If the table is still too wide, then compressed wide columns are split into 2kB chunks and move to a TOAST table&lt;/li&gt;&#xA;&lt;li&gt;A 2kB (ish) wide table can be problematic&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;bloat&#34;&gt;Bloat&lt;/h1&gt;&#xA;&lt;h2 id=&#34;what-is-bloat&#34;&gt;What is bloat?&lt;/h2&gt;&#xA;&lt;p&gt;Strictly speaking, bloat is the unused space left behind by a VACUUM that is not a VACUUM FULL.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Query Performance Improvement Part 1</title>
      <link>https://spokey.co.uk/post/query-performance-improvement-part-1/</link>
      <pubDate>Sat, 19 Apr 2025 01:30:19 +0100</pubDate>
      <guid>https://spokey.co.uk/post/query-performance-improvement-part-1/</guid>
      <description>&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;&#xA;&lt;p&gt;Part 1 (this post) looks at some principles and introduces some of the tools in your arsenal.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-2&#34;&gt;Part 2&lt;/a&gt; covers the dreaded PostgreSQL bloat issue as well as how TOAST can help performance, or not.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-3&#34;&gt;Part 3&lt;/a&gt; dives deeper into identifying, investigating and mitigating slow queries.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-4&#34;&gt;Part 4&lt;/a&gt; covers indexing.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://spokey.co.uk/post/query-performance-improvement-part-5&#34;&gt;Part 5&lt;/a&gt; covers rewriting queries.&lt;/p&gt;&#xA;&lt;h1 id=&#34;tldr&#34;&gt;TL;DR&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Scaling up or out is more expensive than spending a couple of hours optimising&lt;/li&gt;&#xA;&lt;li&gt;Get answers, not data&lt;/li&gt;&#xA;&lt;li&gt;Lazy load lookups&lt;/li&gt;&#xA;&lt;li&gt;Eliminate non-essential queries&lt;/li&gt;&#xA;&lt;li&gt;Don&amp;rsquo;t use SERIALIZABLE isolation&lt;/li&gt;&#xA;&lt;li&gt;Make sure auto-analyze is running and have a manual ANALYZE schedule as a safety net&lt;/li&gt;&#xA;&lt;li&gt;Denormalising is usually the wrong solution to performance issues&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;&#xA;&lt;p&gt;Welcome to this series of blog posts which will hopefully walk you through everything you need to know about improving query performance, specifically in PostgreSQL. The basic principles apply to all databases, though, even if implementation differences mean that different databases find different things painful.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Welcome</title>
      <link>https://spokey.co.uk/post/welcome/</link>
      <pubDate>Fri, 18 Apr 2025 20:48:53 +0100</pubDate>
      <guid>https://spokey.co.uk/post/welcome/</guid>
      <description>&lt;p&gt;Welcome to my humble blog, a venue for mithering, wittering, raging, moaning and occasionally useful posts.&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://spokey.co.uk/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://spokey.co.uk/readme/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://spokey.co.uk/images/DBAProTip.png&#34; alt=&#34;DBA Pro Tip&#34;&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
